export default async function ({ addon, global, console }) {
  const blockSwitches = {
    motion_turnright: ['motion_turnleft'],
    motion_turnleft: ['motion_turnright'],
    operator_equals: ['operator_gt', 'operator_lt'],
    operator_gt: ['operator_equals', 'operator_lt'],
    operator_lt: ['operator_equals', 'operator_gt'],
    operator_add: ['operator_subtract', 'operator_multiply', 'operator_divide', 'operator_mod'],
    operator_subtract: ['operator_add', 'operator_multiply', 'operator_divide', 'operator_mod'],
    operator_multiply: ['operator_add', 'operator_subtract', 'operator_divide', 'operator_mod'],
    operator_divide: ['operator_add', 'operator_subtract', 'operator_multiply', 'operator_mod'],
    operator_mod: ['operator_add', 'operator_subtract', 'operator_multiply', 'operator_divide'],
    motion_setx: ['motion_changexby', 'motion_sety', 'motion_changeyby'],
    motion_changexby: ['motion_setx', 'motion_sety', 'motion_changeyby'],
    motion_sety: ['motion_setx', 'motion_changexby', 'motion_changeyby'],
    motion_changeyby: ['motion_setx', 'motion_changexby', 'motion_sety'],
    data_setvariableto: ['data_changevariableby'],
    data_changevariableby: ['data_setvariableto'],
    motion_xposition: ['motion_yposition'],
    motion_yposition: ['motion_xposition'],
    looks_show: ['looks_hide'],
    looks_hide: ['looks_show'],
    control_if: ['control_if_else'],
    control_if_else: ['control_if'], // TODO: what to do with blocks in the else branch?
    sensing_mousex: ['sensing_mousey'],
    sensing_mousey: ['sensing_mousex'],
  };

  const blockToDom = (block) => {
    // Blockly/Scratch already have logic to convert blocks to XML, but this is not part of the global Blockly object.
    // Instead, we'll convert the entire workspace to XML and search for the block.
    // Certainly not ideal. In the future we should to bring in our own Blockly.Xml.blockToDom
    const workspaceXml = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());
    // TODO: this won't work if the block ID has some very strange and unusual characters.
    // However, IDs generated by Scratch shouldn't have those so that probably isn't a big deal.
    return workspaceXml.querySelector(`[id="${block.id}"]`);
  };

  const switchBlockCallback = (block, newOpcode) => () => {
    // Make a copy of the block with the proper type set.
    // It doesn't seem to be possible to change a Block's type after it's created, so we'll just make a new block instead.
    const xml = blockToDom(block);
    xml.setAttribute('type', newOpcode);

    const id = block.id;
    const parent = block.getParent();

    let parentConnection;
    let blockConnectionType;
    if (parent) {
      // If the block has a parent, find out which connection we will have to reattach later.
      const parentConnections = parent.getConnections_();
      const blockConnections = block.getConnections_();
      const blockToParentConnection = blockConnections.find((c) => c.targetConnection && c.targetConnection.sourceBlock_ === parent);
      blockConnectionType = blockToParentConnection.type;
      parentConnection = parentConnections.find((c) => c.targetConnection && c.targetConnection.sourceBlock_ === block);
    }

    // Remove the old black and insert the new one.
    block.dispose();
    Blockly.getMainWorkspace().paste(xml);
    // The new block will have the same ID as the old one.
    const newBlock = Blockly.getMainWorkspace().getBlockById(id);

    if (parentConnection) {
      const newBlockConnections = newBlock.getConnections_();
      const newBlockConnection = newBlockConnections.find((c) => c.type === blockConnectionType);
      newBlockConnection.connect(parentConnection);
    }

    // TODO: unmangle undo history
  };

  const customContextMenuHandler = function (options) {
    if (this._blockswitchingNativeContextMenu) {
      this._blockswitchingNativeContextMenu(options);
    }

    const switches = blockSwitches[this.type];
    for (const opcode of switches) {
      options.push({
        enabled: true,
        text: opcode, // TODO: display human readable name; translate
        callback: switchBlockCallback(this, opcode)
      });
    }
  };

  const injectCustomContextMenu = (block) => {
    const type = block.type;
    if (!blockSwitches.hasOwnProperty(type)) {
      return;
    }

    block._blockswitchingNativeContextMenu = block.customContextMenu;
    block.customContextMenu = customContextMenuHandler;
  }

  const changeListener = (change) => {
    if (change.type !== 'create') {
      return;
    }

    for (const id of change.ids) {
      const block = Blockly.getMainWorkspace().getBlockById(id);
      if (!block) continue;
      injectCustomContextMenu(block);
    }
  };

  const inject = (workspace) => {
    workspace.getAllBlocks().forEach(injectCustomContextMenu);
    workspace.addChangeListener(changeListener);
  };

  if (addon.tab.editorMode === "editor") {
    const interval = setInterval(() => {
      if (Blockly.getMainWorkspace()) {
        inject(Blockly.getMainWorkspace());
        clearInterval(interval);
      }
    }, 100);
  }
  addon.tab.addEventListener(
    "urlChange",
    () => addon.tab.editorMode === "editor" && inject(Blockly.getMainWorkspace())
  );
}
